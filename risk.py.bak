import math
import random
import global_vars as gv
import utils
import chess
#import players


class Territory(object):
    def __init__(self, name, owner, narmies, neighbours):
        self.name = name
        self.lname = name.lower()
        self.owner = owner
        self.narmies = narmies
        self.neighbours = neighbours
        
    def reassign_owner(self, player):
        self.owner = player
        eliminate_dead_players()
        
        
class Board(object):

    class TerritoryNotFound(Exception):
        pass    
    
    # board object should be a list of lists with a territory in each entry
    def __init__(self):
        self.nrows = random.randint(3,5)
        self.ncols = random.randint(3,5)
        self.nterrs = self.nrows*self.ncols
        self.territory_array = []
        # Construct the territory array and
        # assign the territory names (read in names from a .txt)
        with open('territory_names.chr') as territory_name_file:
            for row in xrange(self.nrows):
                self.territory_array.append([])
                for col in xrange(self.ncols):
                    name = territory_name_file.readline()[:-1]
                    self.territory_array[row].append(
                      Territory(name, owner=None, narmies=0, neighbours = None)
                                                    )
        
        # figure out territory neighbours
        for col in xrange(self.ncols):
            for row in xrange(self.nrows):
                self.territory_array[row][col].neighbours = []
                for col1, row1 in [
                                  (col+1, row),
                                  (col-1, row),
                                  (col, row+1),
                                  (col, row-1),
                                  ]:
                    if (col1 < self.ncols and col1 >= 0
                       and row1 < self.nrows and row1 >= 0):
                        self.territory_array[row][col].neighbours.append(
                                    self.territory_array[row1][col1]
                                    )
        
        # assign territory owners
        nterrs_empty = self.nterrs
        nterrs_per_player = self.n_initial_terrs_per_player()
        for player in gv.PLAYERS.keys():
            nterrs_left_for_player = nterrs_per_player
            while nterrs_left_for_player > 0 and nterrs_empty > 0:
                row = random.randint(0, self.nrows-1)
                col = random.randint(0, self.ncols-1)
                if self.territory_array[row][col].owner == None:
                    self.territory_array[row][col].owner = player
                    nterrs_left_for_player -= 1
                    nterrs_empty -= 1
        # assign any remainder to the player lucky enough to be at the top
        # of the dictionary. Does not affect # starting armies.
        for col in xrange(self.ncols):
            for row in xrange(self.nrows):
                if self.territory_array[row][col].owner == None:
                    self.territory_array[row][col].owner = gv.PLAYERS.keys()[0]
                
        # set up global alias to board's territory array (I sure hope this works!)
        gv.TERRITORIES = self.construct_territory_dict()

    def place_initial_armies(self):
        nterrs_per_player = self.n_initial_terrs_per_player()
        for player in gv.PLAYERS.keys():
            n_init_armies = math.floor(nterrs_per_player*2.5)
            for col in xrange(self.ncols):
                for row in xrange(self.nrows):
                    # put an army on each territory
                    if self.territory_array[row][col].owner == player:
                        self.territory_array[row][col].narmies += 1
                        n_init_armies -= 1
            while n_init_armies > 0:
                row = random.randint(0, self.nrows-1)
                col = random.randint(0, self.ncols-1)
                if self.territory_array[row][col].owner == player:
                    self.territory_array[row][col].narmies += 1
                    n_init_armies -= 1

    def n_initial_terrs_per_player(self):
        return self.nterrs/len(gv.PLAYERS.keys())                   

    def territory_by_name(self, name):
        # return the territory object with a given name!
        for col in xrange(self.ncols):
            for row in xrange(self.nrows):
                if self.territory_array[row][col].name == name:
                    return self.territory_array[row][col]
        raise self.TerritoryNotFound

    def construct_territory_dict(self):
        terrdict = {}
        for col in xrange(self.ncols):
            for row in xrange(self.nrows):
                terrdict[self.territory_array[row][col].lname] = \
                                                self.territory_array[row][col]
        return terrdict
        
    def print_board(self):
        w = 10.
        for row in xrange(self.nrows):
            subrows = ['']*4
            for col in xrange(self.ncols):
                namelen = min(len(self.territory_array[row][col].name),int(w))
                namestring = self.territory_array[row][col].name[0:namelen]
                ownerlen = min(len(self.territory_array[row][col].owner),int(w))
                ownerstring = self.territory_array[row][col].owner[0:ownerlen]
                armystring = str(min(self.territory_array[row][col].narmies,10**int(w)))
                armylen = len(armystring)
                subrows[0] += '+' + '-'*int(w)
                subrows[1] += '|' + ' '*int(math.floor((w-float(namelen))/2.)) + namestring + ' '*int(math.ceil((w-float(namelen))/2.))
                subrows[2] += '|' + ' '*int(math.floor((w-float(ownerlen))/2.)) + ownerstring + ' '*int(math.ceil((w-float(ownerlen))/2.))
                subrows[3] += '|' + ' '*int(math.floor((w-float(armylen))/2.)) + armystring + ' '*int(math.ceil((w-float(armylen))/2.))
            subrows[0]+='+'
            for isr in xrange(1,4):
                subrows[isr]+='|'
            for subrow in subrows:
                print subrow
        print ('+' + '-'*int(w))*self.ncols+'+'

def setup_board():
    print "Setting up the risk board."
    print "In this version, territories are set up randomly."
    print "In this version, initial army placement is randomised."    
    gv.BOARD = Board()
    gv.BOARD.place_initial_armies()

def count_owned_territories(player):
    n_owned_territories = 0
    for territory in gv.TERRITORIES.keys():
        if gv.TERRITORIES[territory].owner == player:
            n_owned_territories += 1
    return n_owned_territories

def count_army_allowance():
    return int(math.floor(count_owned_territories(gv.CURR_PLAYER)/3.))

def choose_n_armies_to_add(n_reinforce_armies):
    n_armies_to_add = 1e6
    while n_armies_to_add > n_reinforce_armies:
        n_armies_to_add = int(utils.handle_user_input("Add how many armies?"))
        if n_armies_to_add > n_reinforce_armies:
            print "You don't have that many, try again!"
    return n_armies_to_add

def reinforce_a_territory(n_reinforce_armies):
    territory_choice = utils.handle_user_input(
            "Select a territory to reinforce.").lower()
    if territory_choice in gv.TERRITORIES.keys():
        if gv.TERRITORIES[territory_choice].owner == gv.CURR_PLAYER:
            n_armies_to_add = choose_n_armies_to_add(n_reinforce_armies)
            gv.TERRITORIES[territory_choice].narmies += n_armies_to_add
            n_reinforce_armies -= n_armies_to_add
            gv.BOARD.print_board()
        else:
            print "Not your territory!"
    else:
        print "Invalid territory choice, try again!"
    return n_reinforce_armies

def process_build_turn():
    n_reinforce_armies = count_army_allowance()
    print "You have " + str(n_reinforce_armies) + " armies to place."
    while n_reinforce_armies > 0:
        n_reinforce_armies = reinforce_a_territory(n_reinforce_armies)

def choose_attack_from():
    print "Choose territory to attack from, from the following list:"
    attack_from_list = []
    for unused_key, territory in gv.TERRITORIES.items():
        if territory.owner == gv.CURR_PLAYER and territory.narmies > 1:
            for neighbour in territory.neighbours:
                if neighbour.owner != gv.CURR_PLAYER:
                    print territory.name
                    attack_from_list.append(territory.lname)
                    break
    attack_from = utils.handle_user_input('')
    while not attack_from in attack_from_list:
        print "Can't attack from there, choose again."
        attack_from = utils.handle_user_input('')
    return attack_from
    
def choose_attack_to(attack_from):
    print "Choose territory to attack, from the following list:"
    for territory in gv.TERRITORIES[attack_from].neighbours:
        if territory.owner != gv.CURR_PLAYER:
            print territory.name
    return utils.handle_user_input('')

def choose_narmies_to_attack_with(attack_from):
    narmies_to_attack_with = 1e6
    print "There are " + str(gv.TERRITORIES[attack_from].narmies-1) \
            + " armies available for attack."
    while narmies_to_attack_with >= gv.TERRITORIES[attack_from].narmies:
        narmies_to_attack_with = int(utils.handle_user_input(
                "Choose number of armies to attack with"
                ))
        if narmies_to_attack_with >= gv.TERRITORIES[attack_from].narmies:
            print "You must leave at least one army at home, try again!"
    return narmies_to_attack_with

def attackable_neighbours_exist():
    able_to_attack = False
    for unused_key, territory in gv.TERRITORIES.items():
        if territory.owner == gv.CURR_PLAYER and territory.narmies > 1:
            for neighbour in territory.neighbours:
                if neighbour.owner != gv.CURR_PLAYER:
                    able_to_attack = True
    if not able_to_attack:
        print "No possiblities for attack!"
    return able_to_attack

def process_attack_turn():
    if not attackable_neighbours_exist():
        print "Not possible to attack! Build instead."
        process_build_turn()
    while attackable_neighbours_exist():
        attack_from = choose_attack_from()
        attack_to = choose_attack_to(attack_from)
        narmies_to_attack_with = choose_narmies_to_attack_with(attack_from)
        narmies_attacker, narmies_defender = chess.play_chess(
                        narmies_to_attack_with,
                        gv.TERRITORIES[attack_to].narmies
                        )
        if narmies_defender == 0:
            print "Defender defeated!"
            gv.TERRITORIES[attack_from].narmies -= narmies_to_attack_with
            gv.TERRITORIES[attack_to].narmies = narmies_attacker
            gv.TERRITORIES[attack_to].reassign_owner(gv.CURR_PLAYER)
        else:
            print "Attacker repelled!"
            gv.TERRITORIES[attack_from].narmies -= \
                                narmies_to_attack_with - narmies_attacker
            gv.TERRITORIES[attack_to].narmies = narmies_defender
        gv.BOARD.print_board()
        while utils.handle_user_input("Continue to attack?") not in \
              ['y', 'yes', 'ok', 'sure', 'of course', 'why not?', 'onward!', 'fight on, you dogs!']:
            if utils.handle_user_input("Had enough fighting?") in \
              ['y', 'yes', 'ok', 'sure', 'of course', 'sadly, yes.', "i'm a coward", "please don't tell my mum"]:
                  return 'Chickened out'
        
def eliminate_dead_players():
    for player in gv.PLAYERS:
        if count_owned_territories(player) == 0:
            print gv.PLAYERS[player].name + "is out!"
            del gv.PLAYERS[player]

def check_for_victory():
    if len(gv.PLAYERS) == 1:
        print str(gv.PLAYERS[gv.PLAYERS.keys()[0]].name) + " wins!"
        return True
    else:
        return False
